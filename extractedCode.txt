import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:liquid_glass_renderer/liquid_glass_renderer.dart';
import 'config/glass_effect_config.dart';
import 'dart:typed_data';
import 'package:http/http.dart' as http;
import 'dart:ui';
class SettingsPage extends StatefulWidget {
  const SettingsPage({super.key});
  @override
  State<SettingsPage> createState() => _SettingsPageState();
}
class _SettingsPageState extends State<SettingsPage> {
  int _effectLevel = 1;
  Uint8List? _backgroundImageBytes;
  @override
  void initState() {
    super.initState();
    _loadEffectLevel();
    _loadBackgroundImage();
  }
  Future<void> _loadBackgroundImage() async {
    try {
      final response = await http.get(Uri.parse('https://bing.img.run/uhd.php'));
      if (response.statusCode == 200) {
        setState(() {
          _backgroundImageBytes = response.bodyBytes;
        });
      }
    } catch (e) {
    }
  }
  Future<void> _loadEffectLevel() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    setState(() {
      _effectLevel = prefs.getInt('effectLevel') ?? 1; 
    });
  }
  Future<void> _saveEffectLevel(int level) async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    await prefs.setInt('effectLevel', level);
  }
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: null,
      body: Stack(
        children: [
          if (_backgroundImageBytes != null)
            Positioned.fill(
              child: Transform.scale(
                scale: 1, 
                child: Image.memory(
                  _backgroundImageBytes!,
                  fit: BoxFit.cover, 
                  alignment: Alignment.center,
                ),
              ),
            ),
          if (_backgroundImageBytes != null)
            Positioned.fill(
              child: BackdropFilter(
                filter: ImageFilter.blur(sigmaX: 5.0, sigmaY: 5.0),
                child: Container(
                  color: Theme.of(context).brightness == Brightness.dark 
                    ? Colors.black.withValues(alpha: 0.25) 
                    : Colors.white.withValues(alpha: 0.25),
                ),
              ),
            ),
          Align(
            alignment: Alignment.topCenter,
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 600), 
              child: SingleChildScrollView(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const SizedBox(height: 80), 
                    Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: LiquidGlassLayer(
                        settings: GlassEffectConfig.baseSettings(
                          level: _effectLevel <= 1 
                            ? EffectLevel.low 
                            : (_effectLevel == 2 ? EffectLevel.medium : EffectLevel.high)
                        ),
                        child: LiquidGlass.inLayer(
                          shape: const LiquidRoundedRectangle(
                            borderRadius: Radius.circular(16.0), 
                          ),
                          child: Container(
                            width: double.infinity,
                            padding: const EdgeInsets.all(16.0),
                            decoration: const BoxDecoration(
                              borderRadius: BorderRadius.all(Radius.circular(16.0)),
                            ),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                const Text(
                                  '效果等级',
                                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                                ),
                                const SizedBox(height: 16),
                                Row(
                                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                  children: [
                                    const Text('简单'),
                                    Expanded(
                                      child: Slider(
                                        value: _effectLevel.toDouble(),
                                        min: 1,
                                        max: 3,
                                        divisions: 2, 
                                        label: _effectLevel.toString(),
                                        onChanged: (value) {
                                          setState(() {
                                            _effectLevel = value.toInt();
                                          });
                                        },
                                        onChangeEnd: (value) {
                                          _saveEffectLevel(value.toInt());
                                        },
                                      ),
                                    ),
                                    const Text('复杂'),
                                  ],
                                ),
                                const SizedBox(height: 8),
                                Text(
                                  '当前等级: $_effectLevel',
                                  style: Theme.of(context).textTheme.bodySmall,
                                ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(height: 80), 
                  ],
                ),
              ),
            ),
          ),
          Positioned(
            top: MediaQuery.of(context).padding.top + 12.0,
            left: 12.0,
            child: LiquidGlassLayer(
              settings: GlassEffectConfig.smallButtonSettings(
                level: _effectLevel <= 1 
                  ? EffectLevel.low 
                  : (_effectLevel == 2 ? EffectLevel.medium : EffectLevel.high)
              ),
              child: LiquidGlass.inLayer(
                shape: LiquidRoundedRectangle(
                  borderRadius: const Radius.circular(20.0),
                ),
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(20.0),
                  ),
                  child: Material(
                    color: Colors.transparent,
                    child: InkWell(
                      onTap: () {
                        Navigator.of(context).pop();
                      },
                      borderRadius: BorderRadius.circular(20.0),
                      child: const Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(Icons.arrow_back),
                          SizedBox(width: 6),
                          Text('返回'),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
import 'dart:async';
import 'dart:io' show Platform, File;
import 'dart:ui' as ui;
import 'dart:math';
import 'package:audiotags/audiotags.dart';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:fluttertoast/fluttertoast.dart';
import 'package:liquid_glass_renderer/liquid_glass_renderer.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'config/glass_effect_config.dart';
import 'package:path/path.dart' as path;
import 'package:permission_handler/permission_handler.dart';
import 'package:crypto/crypto.dart'; 
import 'isolate_utils.dart';
class TagEditorUI extends StatefulWidget {
  const TagEditorUI({
    super.key,
    required this.tag,
    required this.filePath,
    this.realFilePath,
    this.additionalFiles,
  });
  final Tag tag;
  final String filePath;
  final String? realFilePath;
  final List<String>? additionalFiles;
  @override
  State<TagEditorUI> createState() => _TagEditorUIState();
}
class _TagEditorUIState extends State<TagEditorUI> with TickerProviderStateMixin {
  EffectLevel effectLevel = EffectLevel.medium;
  int _effectLevelValue = 1;
  late TextEditingController _titleController;
  late TextEditingController _artistController;
  late TextEditingController _albumController;
  late TextEditingController _albumArtistController;
  late TextEditingController _yearController;
  late TextEditingController _genreController;
  late TextEditingController _trackNumberController;
  late TextEditingController _trackTotalController;
  late TextEditingController _discNumberController;
  late TextEditingController _discTotalController;
  late TextEditingController _lyricsController;
  late TextEditingController _durationController;
  late TextEditingController _bpmController;
  late TextEditingController _filenameController;
  late TextEditingController _extensionController;
  late ScrollController _fileListScrollController;
  final _formKey = GlobalKey<FormState>();
  Uint8List? _currentCoverImage;
  ValueNotifier<double>? _md5ProgressNotifier;
  bool _isMd5Checking = false;
  bool _md5Mismatch = false;
  ValueNotifier<bool>? _md5CancelledNotifier;
  late AnimationController _backgroundRotationController;
  late Animation<double> _backgroundRotationAnimation;
  Widget _buildGlassTextFormField({
    required TextEditingController controller,
    required String labelText,
    TextInputType keyboardType = TextInputType.text,
    bool enabled = true,
  }) {
    return Container(
      margin: const EdgeInsets.all(4.0),
      child: Stack(
        children: [
          Positioned.fill(
            child: LiquidGlassLayer(
              settings: GlassEffectConfig.baseSettings(level: effectLevel),
              child: LiquidGlass.inLayer(
                shape: LiquidRoundedRectangle(
                  borderRadius: const Radius.circular(12.0),
                ),
                child: Container(
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(12.0),
                    color: Theme.of(context).brightness == Brightness.dark
                        ? Colors.black.withOpacity(0.2)
                        : Colors.white.withOpacity(0.2),
                  ),
                ),
              ),
            ),
          ),
          TextFormField(
            controller: controller,
            decoration: InputDecoration(
              labelText: labelText,
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12.0),
                borderSide: BorderSide.none,
              ),
              enabledBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12.0),
                borderSide: BorderSide.none,
              ),
              focusedBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12.0),
                borderSide: BorderSide.none,
              ),
              filled: true,
              fillColor: Colors.transparent, 
            ),
            style: const TextStyle(
              fontFamily: 'MapleMono',
            ),
            keyboardType: keyboardType,
            enabled: enabled,
          ),
        ],
      ),
    );
  }
  Widget _buildGlassLyricsFormField() {
    return Container(
      margin: const EdgeInsets.all(4.0),
      child: Stack(
        children: [
          Positioned.fill(
            child: LiquidGlassLayer(
              settings: GlassEffectConfig.baseSettings(level: effectLevel),
              child: LiquidGlass.inLayer(
                shape: LiquidRoundedRectangle(
                  borderRadius: const Radius.circular(12.0),
                ),
                child: Container(
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(12.0),
                    color: Theme.of(context).brightness == Brightness.dark
                        ? Colors.black.withOpacity(0.2)
                        : Colors.white.withOpacity(0.2),
                  ),
                ),
              ),
            ),
          ),
          TextFormField(
            controller: _lyricsController,
            decoration: InputDecoration(
              labelText: '歌词',
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12.0),
                borderSide: BorderSide.none,
              ),
              enabledBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12.0),
                borderSide: BorderSide.none,
              ),
              focusedBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12.0),
                borderSide: BorderSide.none,
              ),
              filled: true,
              fillColor: Colors.transparent, 
            ),
            style: const TextStyle(
              fontFamily: 'MapleMono',
            ),
            maxLines: null,
            expands: true,
          ),
        ],
      ),
    );
  }
  @override
  void initState() {
    super.initState();
    _loadEffectLevel();
    _titleController = TextEditingController(text: widget.tag.title);
    _artistController = TextEditingController(text: widget.tag.trackArtist);
    _albumController = TextEditingController(text: widget.tag.album);
    _albumArtistController = TextEditingController(text: widget.tag.albumArtist);
    _yearController = TextEditingController(text: widget.tag.year?.toString());
    _genreController = TextEditingController(text: widget.tag.genre);
    _trackNumberController = TextEditingController(text: widget.tag.trackNumber?.toString());
    _trackTotalController = TextEditingController(text: widget.tag.trackTotal?.toString());
    _discNumberController = TextEditingController(text: widget.tag.discNumber?.toString());
    _discTotalController = TextEditingController(text: widget.tag.discTotal?.toString());
    _lyricsController = TextEditingController(text: widget.tag.lyrics);
    _durationController = TextEditingController(text: widget.tag.duration?.toString());
    _bpmController = TextEditingController(text: widget.tag.bpm?.toString());
    String fileName = path.basenameWithoutExtension(widget.filePath);
    if (fileName.endsWith('_original')) {
      fileName = fileName.substring(0, fileName.length - 9); 
    }
    String fileExtension = path.extension(widget.filePath);
    _filenameController = TextEditingController(text: fileName);
    _extensionController = TextEditingController(text: fileExtension);
    _fileListScrollController = ScrollController();
    final bool isBatchMode = widget.additionalFiles != null && widget.additionalFiles!.isNotEmpty;
    if (!isBatchMode && widget.tag.pictures.isNotEmpty) {
      _currentCoverImage = widget.tag.pictures.first.bytes;
    }
    _backgroundRotationController = AnimationController(
      duration: const Duration(seconds: 60), 
      vsync: this,
    )..repeat(); 
    _backgroundRotationAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(_backgroundRotationController);
    if (isBatchMode) {
      _checkAndLoadConsistentCoverImage();
    }
  }
  Future<void> _loadEffectLevel() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    setState(() {
      _effectLevelValue = prefs.getInt('effectLevel') ?? 1; 
      effectLevel = _effectLevelValue <= 1 
        ? EffectLevel.low 
        : (_effectLevelValue == 2 ? EffectLevel.medium : EffectLevel.high);
    });
  }
  Future<void> _checkAndLoadConsistentCoverImage() async {
    try {
      if (kDebugMode) {
        print('KDEBUG: 检查批量编辑模式下的封面一致性');
      }
      final List<String> allFiles = [
        widget.filePath,
        if (widget.additionalFiles != null) ...widget.additionalFiles!
      ];
      if (kDebugMode) {
        print('KDEBUG: 总共 ${allFiles.length} 个文件需要检查');
        for (int i = 0; i < allFiles.length; i++) {
          print('KDEBUG: 文件 $i: ${allFiles[i]}');
        }
      }
      List<Tag?> tags = [];
      for (String filePath in allFiles) {
        if (kDebugMode) {
          print('KDEBUG: 正在读取文件标签: $filePath');
        }
        final tag = await AudioTags.read(filePath);
        tags.add(tag);
      }
      if (kDebugMode) {
        print('KDEBUG: 成功读取 ${tags.length} 个标签');
      }
      bool hasCoverInAllFiles = true;
      for (int i = 0; i < tags.length; i++) {
        Tag? tag = tags[i];
        if (tag == null || tag.pictures.isEmpty) {
          hasCoverInAllFiles = false;
          if (kDebugMode) {
            print('KDEBUG: 文件 $i 没有封面图片');
          }
          break;
        }
      }
      if (!hasCoverInAllFiles) {
        if (kDebugMode) {
          print('KDEBUG: 并非所有文件都有封面图片');
        }
        return;
      }
      List<String> coverMD5s = [];
      final int total = tags.length;
      final ValueNotifier<double> md5Progress = ValueNotifier<double>(0.0);
      final ValueNotifier<bool> md5Cancelled = ValueNotifier<bool>(false);
      setState(() {
        _md5ProgressNotifier = md5Progress;
        _md5CancelledNotifier = md5Cancelled;
        _isMd5Checking = true;
        _md5Mismatch = false;
      });
      for (int i = 0; i < tags.length; i++) {
        if (md5Cancelled.value) {
          if (kDebugMode) print('KDEBUG: MD5 校验被用户取消');
          break;
        }
        Tag? tag = tags[i];
        if (tag != null && tag.pictures.isNotEmpty) {
          final bytes = tag.pictures.first.bytes;
          final digest = await compute(md5.convert, bytes);
          coverMD5s.add(digest.toString());
          md5Progress.value = (i + 1) / total;
          if (kDebugMode) {
            print('KDEBUG: 文件 $i 封面MD5: ${digest.toString()}');
          }
        } else {
          md5Progress.value = (i + 1) / total;
          if (kDebugMode) {
            print('KDEBUG: 文件 $i 没有封面，跳过 MD5 计算');
          }
        }
      }
      final bool wasCancelled = md5Cancelled.value;
      bool allCoversSame = false;
      if (!wasCancelled && coverMD5s.isNotEmpty) {
        allCoversSame = coverMD5s.every((md5) => md5 == coverMD5s.first);
      }
      setState(() {
        _isMd5Checking = false;
        _md5ProgressNotifier = null;
        _md5CancelledNotifier = null;
        _md5Mismatch = wasCancelled ? true : !allCoversSame;
        if (allCoversSame) {
          _currentCoverImage = tags.first?.pictures.first.bytes;
        }
      });
    } catch (e) {
      if (kDebugMode) {
        print('KDEBUG: 检查封面一致性时出错: $e');
        print('KDEBUG: 错误堆栈: ${StackTrace.current}');
      }
    }
  }
  Widget _buildGlassDialog({
    Widget? title,
    Widget? content,
    List<Widget>? actions,
    double? maxWidth,
    ValueListenable<double>? progress,
  }) {
    return Center(
      child: LiquidGlassLayer(
        settings: GlassEffectConfig.dialogSettings(level: effectLevel),
        child: LiquidGlass.inLayer(
          shape: LiquidRoundedRectangle(
            borderRadius: const Radius.circular(20.0),
          ),
          child: Container(
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(20.0),
              color: Theme.of(context).dialogBackgroundColor.withOpacity(0.9),
            ),
            padding: const EdgeInsets.all(24.0),
            width: (() {
              final double deviceWidth = MediaQuery.of(context).size.width;
              if (maxWidth != null) {
                return min(deviceWidth * 0.98, maxWidth);
              }
              return deviceWidth * 0.8;
            })(),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                if (title != null) 
                  DefaultTextStyle(
                    style: TextStyle(
                      fontFamily: 'MapleMono',
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                      color: Theme.of(context).textTheme.titleLarge?.color,
                      shadows: [
                        Shadow(
                          color: Colors.black.withOpacity(0.3),
                          blurRadius: 4,
                          offset: const Offset(1, 1),
                        )
                      ],
                    ),
                    child: title,
                  ),
                if (title != null && (progress != null || content != null)) const SizedBox(height: 16),
                if (progress != null) ...[
                  ValueListenableBuilder<double>(
                    valueListenable: progress,
                    builder: (context, value, _) {
                      return Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          LinearProgressIndicator(value: value.clamp(0.0, 1.0)),
                          const SizedBox(height: 12),
                          Text('${(value * 100).toStringAsFixed(0)}%'),
                        ],
                      );
                    },
                  ),
                  const SizedBox(height: 12),
                ],
                if (content != null)
                  DefaultTextStyle(
                    style: TextStyle(
                      fontFamily: 'MapleMono',
                      fontSize: 17,
                      color: Theme.of(context).textTheme.bodyMedium?.color,
                      height: 1.5,
                      shadows: [
                        Shadow(
                          color: Colors.black.withOpacity(0.2),
                          blurRadius: 2,
                          offset: const Offset(0.5, 0.5),
                        )
                      ],
                    ),
                    child: content,
                  ),
                if (actions != null && actions.isNotEmpty) ...[
                  const SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: actions,
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
    );
  }
  void _showGlassDialog({
    Widget? title,
    Widget? content,
    List<Widget>? actions,
    double? maxWidth,
    ValueListenable<double>? progress,
  }) {
    showDialog(
      context: context,
      barrierDismissible: false, 
      builder: (BuildContext context) {
        return _buildGlassDialog(
          title: title,
          content: content,
          actions: actions,
          maxWidth: maxWidth,
          progress: progress,
        );
      },
    );
  }
  void _resetChanges() {
    _showGlassDialog(
      title: const Text('还原更改'),
      content: const Text('确定要还原所有更改吗？'),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context, rootNavigator: true).pop(),
          child: const Text('取消'),
        ),
        TextButton(
          onPressed: () {
            Navigator.of(context, rootNavigator: true).pop(); 
            String fileName = path.basenameWithoutExtension(widget.filePath);
            if (fileName.endsWith('_original')) {
              fileName = fileName.substring(0, fileName.length - 9);
            }
            String fileExtension = path.extension(widget.filePath);
            setState(() {
              _titleController.text = widget.tag.title ?? '';
              _artistController.text = widget.tag.trackArtist ?? '';
              _albumController.text = widget.tag.album ?? '';
              _albumArtistController.text = widget.tag.albumArtist ?? '';
              _yearController.text = widget.tag.year?.toString() ?? '';
              _genreController.text = widget.tag.genre ?? '';
              _trackNumberController.text = widget.tag.trackNumber?.toString() ?? '';
              _trackTotalController.text = widget.tag.trackTotal?.toString() ?? '';
              _discNumberController.text = widget.tag.discNumber?.toString() ?? '';
              _discTotalController.text = widget.tag.discTotal?.toString() ?? '';
              _lyricsController.text = widget.tag.lyrics ?? '';
              _durationController.text = widget.tag.duration?.toString() ?? '';
              _bpmController.text = widget.tag.bpm?.toString() ?? '';
              _filenameController.text = fileName;
              _extensionController.text = fileExtension;
              final bool isBatchMode = widget.additionalFiles != null && widget.additionalFiles!.isNotEmpty;
              _currentCoverImage = (!isBatchMode && widget.tag.pictures.isNotEmpty) ? widget.tag.pictures.first.bytes : null;
            });
          },
          child: const Text('确定'),
        ),
      ],
      maxWidth: 560,
    );
  }
  @override
  void dispose() {
    _titleController.dispose();
    _artistController.dispose();
    _albumController.dispose();
    _albumArtistController.dispose();
    _yearController.dispose();
    _genreController.dispose();
    _trackNumberController.dispose();
    _trackTotalController.dispose();
    _discNumberController.dispose();
    _discTotalController.dispose();
    _lyricsController.dispose();
    _durationController.dispose();
    _bpmController.dispose();
    _filenameController.dispose();
    _extensionController.dispose();
    _fileListScrollController.dispose();
    _backgroundRotationController.dispose(); 
    super.dispose();
  }
  Future<void> _saveTags() async {
    if (_formKey.currentState!.validate()) {
      try {
        final ValueNotifier<double> saveProgress = ValueNotifier<double>(0.0);
        final ValueNotifier<bool> saveCancelled = ValueNotifier<bool>(false);
        _showGlassDialog(
          title: const Text('保存中'),
          content: const Text('正在保存标签信息...'),
          maxWidth: 560,
          progress: saveProgress,
          actions: [
            TextButton(
              onPressed: () {
                saveCancelled.value = true;
                try { Navigator.of(context, rootNavigator: true).pop(); } catch (_) {}
              },
              child: const Text('取消'),
            ),
          ],
        );
        final bool isBatchMode = widget.additionalFiles != null && widget.additionalFiles!.isNotEmpty;
        if (isBatchMode) {
          await _saveAllFiles(saveProgress, saveCancelled);
        } else {
          await _saveDirectly(saveProgress, saveCancelled);
        }
        saveProgress.value = 1.0;
        try { Navigator.of(context, rootNavigator: true).pop(); } catch (_) {}
      } on PlatformException catch (e) {
        if (mounted) {
          Navigator.of(context, rootNavigator: true).pop();
          if (kDebugMode) {
            print('保存失败: ${e.message}');
          }
          _showGlassDialog(
            title: const Text('保存失败'),
            content: Text('保存失败: ${e.message}'),
            actions: [
              TextButton(
                onPressed: () {
                  Navigator.of(context, rootNavigator: true).pop();
                },
                child: const Text('确定'),
              ),
            ],
            maxWidth: 560,
          );
        }
      } catch (e) {
        if (mounted) {
          Navigator.of(context, rootNavigator: true).pop();
          _showGlassDialog(
            title: const Text('保存失败'),
            content: Text('保存失败: $e'),
            actions: [
              TextButton(
                onPressed: () {
                  Navigator.of(context, rootNavigator: true).pop();
                },
                child: const Text('确定'),
              ),
            ],
            maxWidth: 560,
          );
          if (kDebugMode) {
            print('KDEBUG: 保存标签时出错: $e');
            print('KDEBUG: 错误堆栈: ${StackTrace.current}');
          }
        }
      }
    }
  }
  Future<void> _saveAllFiles(ValueNotifier<double>? progress, ValueNotifier<bool>? cancel) async {
    try {
      if (kDebugMode) {
        print('KDEBUG: 开始批量保存文件');
      }
      final List<String> allFiles = [
        widget.filePath,
        if (widget.additionalFiles != null) ...widget.additionalFiles!
      ];
      if (kDebugMode) {
        print('KDEBUG: 总共需要保存 ${allFiles.length} 个文件');
        for (int i = 0; i < allFiles.length; i++) {
          print('KDEBUG: 文件 $i: ${allFiles[i]}');
        }
      }
      List<Picture>? pictures;
      if (_currentCoverImage != null) {
        pictures = [Picture(bytes: _currentCoverImage!, mimeType: MimeType.jpeg, pictureType: PictureType.other)];
      }
      final updatedTag = Tag(
        title: _titleController.text,
        trackArtist: _artistController.text,
        album: _albumController.text,
        albumArtist: _albumArtistController.text,
        genre: _genreController.text,
        year: _yearController.text.isNotEmpty ? int.tryParse(_yearController.text) : null,
        trackNumber: _trackNumberController.text.isNotEmpty ? int.tryParse(_trackNumberController.text) : null,
        trackTotal: _trackTotalController.text.isNotEmpty ? int.tryParse(_trackTotalController.text) : null,
        discNumber: _discNumberController.text.isNotEmpty ? int.tryParse(_discNumberController.text) : null,
        discTotal: _discTotalController.text.isNotEmpty ? int.tryParse(_discTotalController.text) : null,
        lyrics: _lyricsController.text,
        duration: widget.tag.duration, 
        bpm: _bpmController.text.isNotEmpty ? double.tryParse(_bpmController.text) : null,
        pictures: pictures ?? const [], 
      );
      int successCount = 0;
      List<String> failedFiles = [];
      for (int i = 0; i < allFiles.length; i++) {
        String filePath = allFiles[i];
        if (kDebugMode) {
          print('KDEBUG: 正在保存文件 $i: $filePath');
        }
        try {
          await AudioTags.write(filePath, updatedTag);
          successCount++;
          final int total = allFiles.length;
          progress?.value = ((i + 1) / total) * 0.5;
          if (kDebugMode) {
            print('KDEBUG: 文件保存成功: $filePath');
          }
        } catch (e) {
          if (kDebugMode) {
            print('KDEBUG: 保存文件时出错 $filePath: $e');
          }
          failedFiles.add(filePath);
          final int total = allFiles.length;
          progress?.value = ((i + 1) / total) * 0.5;
        }
      }
      if (kDebugMode) {
        print('KDEBUG: 所有文件保存完成，成功: $successCount，失败: ${failedFiles.length}');
      }
      await _saveEachFileWithFileSaver(allFiles, successCount, failedFiles, progress, cancel);
    } catch (e) {
      if (kDebugMode) {
        print('KDEBUG: 批量保存标签失败: $e');
      }
      rethrow;
    }
  }
  Future<void> _saveEachFileWithFileSaver(List<String> allFiles, int successCount, List<String> failedFiles, ValueNotifier<double>? progress, ValueNotifier<bool>? cancel) async {
    if (kDebugMode) {
      print('KDEBUG: 开始为每个文件执行保存流程，总文件数: ${allFiles.length}');
    }
    if (mounted) {
      Navigator.of(context, rootNavigator: true).pop();
    }
    if (mounted) {
      _showGlassDialog(
        title: const Text('批量保存'),
        content: Text('正在保存文件...\n已完成: 0/${allFiles.length}'),
        maxWidth: 560,
        progress: progress,
        actions: [
        ],
      );
    }
    int savedCount = 0;
    List<String> saveFailedFiles = [];
    for (int i = 0; i < allFiles.length; i++) {
      if (cancel?.value == true) {
        if (kDebugMode) print('KDEBUG: 保存操作被取消，停止导出');
        break;
      }
      String filePath = allFiles[i];
      String fileName = path.basenameWithoutExtension(filePath);
      String fileExtension = path.extension(filePath);
      if (fileName.endsWith('_original')) {
        fileName = fileName.substring(0, fileName.length - 9); 
      }
      if (fileName.contains('_modified_')) {
        fileName = fileName.substring(0, fileName.lastIndexOf('_modified_'));
      } else if (fileName.endsWith('_modified')) {
        fileName = fileName.substring(0, fileName.length - 9); 
      }
      try {
        if (kDebugMode) {
          print('KDEBUG: 正在保存文件 $i: $filePath');
          print('KDEBUG: 处理后的文件名: $fileName$fileExtension');
        }
        if (mounted) {
          try { Navigator.of(context, rootNavigator: true).pop(); } catch (_) {}
          _showGlassDialog(
            title: const Text('批量保存'),
            content: Text('正在保存文件...\n已完成: $savedCount/${allFiles.length}\n当前: $fileName$fileExtension'),
            maxWidth: 560,
            progress: progress,
            actions: [
            ],
          );
        }
        String suggestedFileName = '$fileName$fileExtension';
        if (kDebugMode) {
          print('KDEBUG: 保存文件建议名: $suggestedFileName');
        }
        if (Platform.isAndroid) {
          await _saveFileForAndroidSingle(filePath, fileName, fileExtension, "");
        } else {
          final String? outputFile = await FilePicker.platform.saveFile(
            dialogTitle: '请选择保存位置:',
            fileName: suggestedFileName,
          );
          if (outputFile != null) {
            if (kDebugMode) {
              print('KDEBUG: 用户选择的输出文件路径: $outputFile');
              print('KDEBUG: 从缓存文件复制: $filePath');
            }
            final saveFile = File(filePath);
            await saveFile.copy(outputFile);
            if (kDebugMode) {
              print('KDEBUG: 文件已成功复制到: $outputFile');
            }
          } else {
            saveFailedFiles.add(filePath);
            if (kDebugMode) {
              print('KDEBUG: 用户取消了保存操作: $filePath');
            }
          }
        }
        savedCount++;
        final int total = allFiles.length;
        progress?.value = 0.5 + (savedCount / total) * 0.5;
      } catch (e) {
        saveFailedFiles.add(filePath);
        if (kDebugMode) {
          print('KDEBUG: 保存文件时出错 $filePath: $e');
        }
      }
    }
    if (cancel?.value == true) {
      if (mounted) {
        _showGlassDialog(
          title: const Text('已取消'),
          content: const Text('保存操作已取消'),
          actions: [
            TextButton(
              onPressed: () { Navigator.of(context, rootNavigator: true).pop(); },
              child: const Text('确定'),
            ),
          ],
          maxWidth: 560,
        );
      }
      return;
    }
    if (mounted) {
      Navigator.of(context, rootNavigator: true).pop(); 
      String resultMessage = '标签保存完成:\n'
          '成功保存标签: $successCount/${allFiles.length}\n'
          '成功保存文件: $savedCount/${allFiles.length}';
      if (failedFiles.isNotEmpty) {
        resultMessage += '\n标签保存失败: ${failedFiles.length} 个文件';
      }
      if (saveFailedFiles.isNotEmpty) {
        resultMessage += '\n文件保存失败: ${saveFailedFiles.length} 个文件';
      }
      _showGlassDialog(
        title: const Text('批量操作完成'),
        content: Text(resultMessage),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context, rootNavigator: true).pop();
            },
            child: const Text('确定'),
          ),
        ],
        maxWidth: 560,
      );
    }
  }
  Future<void> _saveFileForAndroidSingle(String sourceFilePath, String baseFileName, String fileExtension, String timestamp) async {
    try {
      if (kDebugMode) {
        print('KDEBUG: 使用Android平台单文件保存方法');
        print('KDEBUG: 源文件路径: $sourceFilePath');
        print('KDEBUG: 基础文件名: $baseFileName');
        print('KDEBUG: 文件扩展名: $fileExtension');
      }
      bool hasPermission = await _requestStoragePermission();
      if (!hasPermission) {
        if (kDebugMode) {
          print('KDEBUG: 存储权限被拒绝');
        }
        if (mounted) {
          _showGlassDialog(
            title: const Text(
              '权限不足',
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
            ),
            content: const Text('需要存储权限才能保存文件'),
            actions: [
              TextButton(
                onPressed: () {
                  Navigator.of(context, rootNavigator: true).pop();
                },
                child: const Text('确定'),
              ),
            ],
          );
        }
        return;
      }
      String cleanFileName = baseFileName;
      if (cleanFileName.contains('_modified_')) {
        cleanFileName = cleanFileName.substring(0, cleanFileName.lastIndexOf('_modified_'));
      } else if (cleanFileName.endsWith('_modified')) {
        cleanFileName = cleanFileName.substring(0, cleanFileName.length - 9); 
      }
      String targetFileName = '$cleanFileName$fileExtension';
      String downloadPath = '/sdcard/Download/$targetFileName';
      File targetFile = File(downloadPath);
      await targetFile.create(recursive: true);
      if (kDebugMode) {
        print('KDEBUG: 尝试将文件保存到: $downloadPath');
      }
      File sourceFile = File(sourceFilePath);
      await sourceFile.copy(downloadPath);
      if (kDebugMode) {
        print('KDEBUG: 文件已成功保存到: $downloadPath');
      }
      if (mounted) {
        Fluttertoast.showToast(
          msg: '文件已保存到: $downloadPath',
          toastLength: Toast.LENGTH_LONG,
          gravity: ToastGravity.BOTTOM,
        );
      }
    } catch (e) {
      if (kDebugMode) {
        print('KDEBUG: 单文件保存失败: $e');
      }
      if (mounted) {
        _showGlassDialog(
          title: const Text(
            '保存失败',
            style: TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          content: Text('保存失败: $e'),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context, rootNavigator: true).pop();
              },
              child: const Text('确定'),
            ),
          ],
        );
      }
      rethrow;
    }
  }
  Future<void> _saveDirectly(ValueNotifier<double>? progress, ValueNotifier<bool>? cancel) async {
    try {
      List<Picture>? pictures;
      if (_currentCoverImage != null) {
        pictures = [Picture(bytes: _currentCoverImage!, mimeType: MimeType.jpeg, pictureType: PictureType.other)];
      }
      final updatedTag = Tag(
        title: _titleController.text,
        trackArtist: _artistController.text,
        album: _albumController.text,
        albumArtist: _albumArtistController.text,
        genre: _genreController.text,
        year: _yearController.text.isNotEmpty ? int.tryParse(_yearController.text) : null,
        trackNumber: _trackNumberController.text.isNotEmpty ? int.tryParse(_trackNumberController.text) : null,
        trackTotal: _trackTotalController.text.isNotEmpty ? int.tryParse(_trackTotalController.text) : null,
        discNumber: _discNumberController.text.isNotEmpty ? int.tryParse(_discNumberController.text) : null,
        discTotal: _discTotalController.text.isNotEmpty ? int.tryParse(_discTotalController.text) : null,
        lyrics: _lyricsController.text,
        duration: widget.tag.duration, 
        bpm: _bpmController.text.isNotEmpty ? double.tryParse(_bpmController.text) : null,
        pictures: pictures ?? const [], 
      );
      final success = await compute(saveAudioTagsInBackground, SaveTagsParams(widget.filePath, updatedTag));
      if (!success) {
        throw Exception('在 isolate 中保存标签失败');
      }
      if (kDebugMode) {
        print('KDEBUG: 标签已直接写入文件: ${widget.filePath}');
        print('KDEBUG: 当前平台: ${Platform.operatingSystem}');
      }
      await _saveWithFileSaver(progress, cancel);
    } catch (e) {
      if (kDebugMode) {
        print('KDEBUG: 直接保存标签失败: $e');
      }
      if (mounted) {
        Navigator.of(context, rootNavigator: true).pop(); 
        _showGlassDialog(
          title: const Text('保存失败'),
          content: Text('保存失败: $e'),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context, rootNavigator: true).pop();
              },
              child: const Text('确定'),
            ),
          ],
        );
      }
    }
  }
  Future<void> _saveWithFileSaver(ValueNotifier<double>? progress, ValueNotifier<bool>? cancel) async {
    try {
      if (cancel?.value == true) {
        if (kDebugMode) print('KDEBUG: 保存已被取消，跳过文件保存器流程');
        return;
      }
      String fileName = _filenameController.text;
      String fileExtension = _extensionController.text;
      String cleanFileName = '$fileName$fileExtension';
      if (kDebugMode) {
        print('KDEBUG: 准备使用文件保存器保存文件');
        print('KDEBUG: 建议的文件名: $cleanFileName');
        print('KDEBUG: 当前平台: ${Platform.operatingSystem}');
      }
      final bool isBatchMode = widget.additionalFiles != null && widget.additionalFiles!.isNotEmpty;
      if (Platform.isAndroid) {
        String userDefinedFileName = '$fileName$fileExtension';
        await _saveFileForAndroid(userDefinedFileName);
        return;
      } else if (Platform.isIOS) {
        if (kDebugMode) {
          print('KDEBUG: iOS平台使用标准文件保存方法');
        }
      } else if (Platform.isWindows) {
        if (kDebugMode) {
          print('KDEBUG: Windows平台使用标准文件保存方法');
        }
      } else if (Platform.isMacOS) {
        if (kDebugMode) {
          print('KDEBUG: macOS平台使用标准文件保存方法');
        }
      } else if (Platform.isLinux) {
        if (kDebugMode) {
          print('KDEBUG: Linux平台使用标准文件保存方法');
        }
      }
      final String? outputFile = await FilePicker.platform.saveFile(
        dialogTitle: '请选择保存位置:',
        fileName: cleanFileName,
      );
      if (cancel?.value == true) {
        if (kDebugMode) print('KDEBUG: 保存已被取消，用户未选择保存位置');
        return;
      }
      if (outputFile != null) {
        if (kDebugMode) {
          print('KDEBUG: 用户选择的输出文件路径: $outputFile');
          print('KDEBUG: 从缓存文件复制: ${widget.filePath}');
        }
        final saveFile = File(widget.filePath);
        await saveFile.copy(outputFile);
        progress?.value = 1.0;
        if (isBatchMode) {
          final List<String> allFiles = [
            widget.filePath,
            if (widget.additionalFiles != null) ...widget.additionalFiles!
          ];
          if (kDebugMode) {
            print('KDEBUG: 批量编辑模式，总共 ${allFiles.length} 个文件已保存标签');
            print('KDEBUG: 其中第一个文件已导出到: $outputFile');
          }
            if (mounted) {
              try { Navigator.of(context, rootNavigator: true).pop(); } catch (_) {}
              _showGlassDialog(
                title: const Text('保存成功'),
                content: Text(
                    '已保存 ${allFiles.length} 个文件的标签。\n'
                    '第一个文件已导出到: $outputFile\n'
                    '其他文件保存在缓存中，请手动导出。'),
                actions: [
                  TextButton(
                    onPressed: () {
                      Navigator.of(context, rootNavigator: true).pop();
                    },
                    child: const Text('确定'),
                  ),
                ],
                maxWidth: 560,
              );
            }
        } else {
          if (kDebugMode) {
            print('KDEBUG: 文件已成功复制到: $outputFile');
          }
          if (mounted) {
            try { Navigator.of(context, rootNavigator: true).pop(); } catch (_) {}
            _showGlassDialog(
              title: const Text('保存成功'),
              content: Text('文件已保存到: $outputFile'),
              actions: [
                TextButton(
                  onPressed: () {
                    Navigator.of(context, rootNavigator: true).pop();
                  },
                  child: const Text('确定'),
                ),
              ],
              maxWidth: 560,
            );
          }
        }
      } else {
        if (mounted) {
          Navigator.of(context, rootNavigator: true).pop(); 
          _showGlassDialog(
            title: const Text('操作取消'),
            content: const Text('保存操作已取消'),
            actions: [
              TextButton(
                onPressed: () {
                  Navigator.of(context, rootNavigator: true).pop();
                },
                child: const Text('确定'),
              ),
            ],
          );
        }
        if (kDebugMode) {
          print('KDEBUG: 用户取消了保存操作');
        }
      }
    } on UnimplementedError catch (e) {
      if (kDebugMode) {
        print('KDEBUG: 文件保存器未实现: $e');
        print('KDEBUG: 当前平台: ${Platform.operatingSystem}');
      }
      if (Platform.isAndroid) {
        String fileName = _filenameController.text;
        String fileExtension = _extensionController.text;
        String userDefinedFileName = '$fileName$fileExtension';
        await _saveFileForAndroid(userDefinedFileName);
        return;
      } else if (Platform.isIOS) {
        if (kDebugMode) {
          print('KDEBUG: iOS平台不支持文件保存器的替代方案');
        }
      } else if (Platform.isWindows || Platform.isMacOS || Platform.isLinux) {
        if (kDebugMode) {
          print('KDEBUG: ${Platform.operatingSystem}平台不支持文件保存器');
        }
      }
      if (mounted) {
        Navigator.of(context, rootNavigator: true).pop(); 
        _showGlassDialog(
          title: const Text('功能不支持'),
          content: const Text('当前平台不支持文件保存器功能'),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context, rootNavigator: true).pop();
              },
              child: const Text('确定'),
            ),
          ],
        );
      }
    } catch (e) {
      if (kDebugMode) {
        print('KDEBUG: 使用文件保存器保存失败: $e');
      }
      if (mounted) {
        Navigator.of(context, rootNavigator: true).pop(); 
        _showGlassDialog(
          title: const Text(
            '保存失败',
            style: TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          content: Text('保存失败: $e'),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context, rootNavigator: true).pop();
              },
              child: const Text('确定'),
            ),
          ],
        );
      }
    }
  }
  Future<void> _saveFileForAndroid(String suggestedName) async {
    try {
      if (kDebugMode) {
        print('KDEBUG: 使用Android平台文件保存方法');
        print('KDEBUG: 建议的文件名: $suggestedName');
      }
      bool hasPermission = await _requestStoragePermission();
      if (!hasPermission) {
        if (kDebugMode) {
          print('KDEBUG: 存储权限被拒绝');
        }
        if (mounted) {
          Navigator.of(context).pop(); 
          _showGlassDialog(
            title: const Text(
              '权限不足',
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
            ),
            content: const Text('需要存储权限才能保存文件'),
            actions: [
              TextButton(
                onPressed: () {
                  Navigator.of(context).pop();
                },
                child: const Text('确定'),
              ),
            ],
          );
        }
        return;
      }
      String downloadPath = '/sdcard/Download/$suggestedName';
      File targetFile = File(downloadPath);
      await targetFile.create(recursive: true);
      if (kDebugMode) {
        print('KDEBUG: 尝试将文件保存到: $downloadPath');
      }
      File sourceFile = File(widget.filePath);
      await sourceFile.copy(downloadPath);
      if (kDebugMode) {
        print('KDEBUG: 文件已成功保存到: $downloadPath');
      }
      if (mounted) {
        Navigator.of(context, rootNavigator: true).pop(); 
        Fluttertoast.showToast(
          msg: '文件已保存到: $downloadPath',
          toastLength: Toast.LENGTH_LONG,
          gravity: ToastGravity.BOTTOM,
        );
      }
    } catch (e) {
      if (kDebugMode) {
        print('KDEBUG: Android平台文件保存失败: $e');
      }
      if (mounted) {
        Navigator.of(context).pop(); 
        _showGlassDialog(
          title: const Text(
            '保存失败',
            style: TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          content: Text('Android平台保存失败: $e'),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context, rootNavigator: true).pop();
              },
              child: const Text('确定'),
            ),
          ],
        );
      }
    }
  }
  Future<bool> _requestStoragePermission() async {
    try {
      if (Platform.isAndroid) {
        final androidVersion = int.tryParse(Platform.operatingSystemVersion.replaceAll(RegExp(r'[^\d.]'), '').split('.').first) ?? 0;
        if (kDebugMode) {
          print('KDEBUG: Android版本: $androidVersion');
        }
        if (androidVersion >= 11) {
          var status = await Permission.manageExternalStorage.status;
          if (!status.isGranted) {
            if (kDebugMode) {
              print('KDEBUG: 请求MANAGE_EXTERNAL_STORAGE权限');
            }
            status = await Permission.manageExternalStorage.request();
            return status.isGranted;
          }
          if (kDebugMode) {
            print('KDEBUG: MANAGE_EXTERNAL_STORAGE权限已授予');
          }
          return true;
        } else {
          var status = await Permission.storage.status;
          if (!status.isGranted) {
            if (kDebugMode) {
              print('KDEBUG: 请求存储权限');
            }
            status = await Permission.storage.request();
            return status.isGranted;
          }
          if (kDebugMode) {
            print('KDEBUG: 存储权限已授予');
          }
          return true;
        }
      }
      return false;
    } catch (e) {
      if (kDebugMode) {
        print('KDEBUG: 权限请求失败: $e');
      }
      return false;
    }
  }
  Future<void> _selectNewCoverImage() async {
    FilePickerResult? result = await FilePicker.platform.pickFiles(
      type: FileType.image,
      withData: true,
      allowedExtensions: ['jpg', 'jpeg', 'png', 'bmp', 'gif'],
    );
    if (result == null || result.files.isEmpty) {
      return;
    }
    final selectedFile = result.files.first;
    try {
      final Uint8List imageData = selectedFile.bytes ?? Uint8List(0);
      Fluttertoast.showToast(
        msg: '正在导入图片: ${selectedFile.name}',
        toastLength: Toast.LENGTH_LONG,
        gravity: ToastGravity.BOTTOM,
      );
      const int maxSize = 3 * 1024 * 1024; 
      if (imageData.length > maxSize) {
        if (mounted) {
          _showGlassDialog(
            title: const Text(
              '文件过大警告',
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
            ),
            content: Text('图片文件过大(${(imageData.length / (1024 * 1024)).toStringAsFixed(2)}MB)，可能导致其他软件读取时崩溃。本软件通常可以正常处理这些问题但加载较慢，且可能无法保存到标签。你可以在封面显示后截图裁切来减小图片文件大小。'),
            actions: [
              TextButton(
                onPressed: () {
                  Navigator.of(context, rootNavigator: true).pop();
                },
                child: const Text('确定'),
              ),
            ],
          );
        }
      }
      if (mounted) {
        setState(() {
          _currentCoverImage = imageData;
        });
      }
      if (kDebugMode) {
        print('KDEBUG: 新封面图片已选择，大小: ${imageData.length} 字节');
      }
    } catch (e) {
      if (kDebugMode) {
        print('KDEBUG: 选择新封面图片时出错: $e');
      }
      if (mounted) {
        _showGlassDialog(
          title: const Text(
            '选择图片出错',
            style: TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          content: Text('选择图片时出错: $e'),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: const Text('确定'),
            ),
          ],
        );
      }
    }
  }
  Widget _buildCoverSection() {
    if (_currentCoverImage != null) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Center(
            child: GestureDetector(
              onTap: _selectNewCoverImage,
              child: Container(
                width: MediaQuery.of(context).size.width * 0.75,
                constraints: const BoxConstraints(maxWidth: 400),
                child: Stack(
                  children: [
                    Positioned.fill(
                      child: LiquidGlassLayer(
                        settings: LiquidGlassSettings(
                          thickness: 6,
                          blur: 0.5,
                          lightAngle: 0.3 * pi,
                          lightIntensity: 0.7,
                          ambientStrength: 0.2,
                          blend: 0.5,
                          refractiveIndex: 1.2,
                          chromaticAberration: 0.2,
                          saturation: 1.05,
                        ),
                        child: LiquidGlass.inLayer(
                          shape: LiquidRoundedRectangle(
                            borderRadius: const Radius.circular(12.0),
                          ),
                          child: Container(
                            decoration: BoxDecoration(
                              borderRadius: BorderRadius.circular(12.0),
                              color: Theme.of(context).brightness == Brightness.dark
                                  ? Colors.black.withOpacity(0.2)
                                  : Colors.white.withOpacity(0.2),
                            ),
                          ),
                        ),
                      ),
                    ),
                    Container(
                      decoration: BoxDecoration(
                        border: Border.all(color: Colors.grey),
                        borderRadius: BorderRadius.circular(12.0),
                      ),
                      child: ClipRRect(
                        borderRadius: BorderRadius.circular(12.0),
                        child: Image.memory(
                          _currentCoverImage!,
                          fit: BoxFit.contain,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
          const SizedBox(height: 16),
          (_isMd5Checking && _md5ProgressNotifier != null)
              ? Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: Row(
                    children: [
                      Expanded(
                        child: ValueListenableBuilder<double>(
                          valueListenable: _md5ProgressNotifier!,
                          builder: (context, value, _) {
                            return Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                LinearProgressIndicator(value: value.clamp(0.0, 1.0)),
                                const SizedBox(height: 6),
                                Text('${(value * 100).toStringAsFixed(0)}%'),
                              ],
                            );
                          },
                        ),
                      ),
                    ],
                  ),
                )
              : (_md5Mismatch
                  ? Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 16.0),
                      child: Row(
                        children: const [
                          Icon(Icons.warning, color: Colors.orange),
                          SizedBox(width: 8),
                          Text('封面不一致', style: TextStyle(color: Colors.orange)),
                        ],
                      ),
                    )
                  : const SizedBox.shrink()),
        ],
      );
    } else {
      return Column(
        children: [
          const SizedBox(height: 16),
          Center(
            child: GestureDetector(
              onTap: _selectNewCoverImage,
              child: Container(
                width: MediaQuery.of(context).size.width * 0.5,
                constraints: const BoxConstraints(maxWidth: 400),
                child: Stack(
                  children: [
                    Positioned.fill(
                      child: LiquidGlassLayer(
                        settings: GlassEffectConfig.baseSettings(level: effectLevel),
                        child: LiquidGlass.inLayer(
                          shape: LiquidRoundedRectangle(
                            borderRadius: const Radius.circular(12.0),
                          ),
                          child: Container(
                            decoration: BoxDecoration(
                              borderRadius: BorderRadius.circular(12.0),
                              color: Theme.of(context).brightness == Brightness.dark
                                  ? Colors.black.withOpacity(0.2)
                                  : Colors.white.withOpacity(0.2),
                            ),
                          ),
                        ),
                      ),
                    ),
                    Container(
                      decoration: BoxDecoration(
                        border: Border.all(color: Colors.grey),
                        borderRadius: BorderRadius.circular(12.0),
                      ),
                      child: Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(Icons.add_photo_alternate, size: 50, color: Colors.grey),
                            Text('点击添加封面图片', style: TextStyle(color: Colors.grey)),
                          ],
                        ),
                      ),
                    ),
                    const SizedBox(height: 16),
                  ],
                ),
              ),
            ),
          ),
          const SizedBox(height: 12),
          (_isMd5Checking && _md5ProgressNotifier != null)
              ? Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: Row(
                    children: [
                      Expanded(
                        child: ValueListenableBuilder<double>(
                          valueListenable: _md5ProgressNotifier!,
                          builder: (context, value, _) {
                            return Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                LinearProgressIndicator(value: value.clamp(0.0, 1.0)),
                                const SizedBox(height: 6),
                                Text('${(value * 100).toStringAsFixed(0)}%'),
                              ],
                            );
                          },
                        ),
                      ),
                    ],
                  ),
                )
              : (_md5Mismatch
                  ? Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 16.0),
                      child: Row(
                        children: const [
                          SizedBox(width: 8),
                          Text('封面不一致，无法统一显示封面', style: TextStyle(color: Colors.orange, fontFamily: 'MapleMono')),
                        ],
                      ),
                    )
                  : const SizedBox.shrink()),
        ],
      );
    }
  }
  List<Widget> _buildFormFields() {
    final bool isBatchMode = widget.additionalFiles != null && widget.additionalFiles!.isNotEmpty;
    List<Widget> fields = [];
    if (!isBatchMode) {
      fields.add(
        Row(
          children: [
            Expanded(
              flex: 3,
              child: _buildGlassTextFormField(
                controller: _filenameController,
                labelText: '文件名',
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              flex: 1,
              child: _buildGlassTextFormField(
                controller: _extensionController,
                labelText: '后缀',
              ),
            ),
          ],
        ),
      );
      fields.add(const SizedBox(height: 16));
    } else {
      fields.add(_buildFileList());
      fields.add(const SizedBox(height: 16));
    }
    fields.add(_buildGlassTextFormField(
      controller: _titleController,
      labelText: '标题',
    ));
    fields.add(const SizedBox(height: 16));
    fields.add(_buildGlassTextFormField(
      controller: _artistController,
      labelText: '艺术家',
    ));
    fields.add(const SizedBox(height: 16));
    fields.add(_buildGlassTextFormField(
      controller: _albumController,
      labelText: '专辑',
    ));
    fields.add(const SizedBox(height: 16));
    fields.add(_buildGlassTextFormField(
      controller: _albumArtistController,
      labelText: '专辑艺术家',
    ));
    fields.add(const SizedBox(height: 16));
    fields.add(
      Row(
        children: [
          Expanded(
            flex: 3,
            child: _buildGlassTextFormField(
              controller: _genreController,
              labelText: '流派',
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            flex: 2,
            child: _buildGlassTextFormField(
              controller: _bpmController,
              labelText: 'BPM',
              keyboardType: TextInputType.numberWithOptions(decimal: true),
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            flex: 2,
            child: _buildGlassTextFormField(
              controller: _yearController,
              labelText: '年份',
              keyboardType: TextInputType.number,
            ),
          ),
        ],
      ),
    );
    fields.add(const SizedBox(height: 16));
    fields.add(
      Row(
        children: [
          Expanded(
            flex: 2,
            child: _buildGlassTextFormField(
              controller: _trackNumberController,
              labelText: '曲目号',
              keyboardType: TextInputType.number,
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            flex: 2,
            child: _buildGlassTextFormField(
              controller: _trackTotalController,
              labelText: '曲目数',
              keyboardType: TextInputType.number,
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            flex: 2,
            child: _buildGlassTextFormField(
              controller: _discNumberController,
              labelText: '光盘号',
              keyboardType: TextInputType.number,
            ),
          ),
        ],
      ),
    );
    fields.add(const SizedBox(height: 16));
    fields.add(
      Row(
        children: [
          Expanded(
            flex: 2,
            child: _buildGlassTextFormField(
              controller: _discTotalController,
              labelText: '光盘数',
              keyboardType: TextInputType.number,
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            flex: 3,
            child: _buildGlassTextFormField(
              controller: _durationController,
              labelText: '时长(秒)',
              keyboardType: TextInputType.number,
              enabled: false, 
            ),
          ),
        ],
      ),
    );
    fields.add(const SizedBox(height: 16));
    fields.add(
      SizedBox(
        height: MediaQuery.of(context).size.height * 0.75,
        child: _buildGlassLyricsFormField(),
      ),
    );
    fields.add(const SizedBox(height: 24));
    return fields;
  }
  Widget _buildFileList() {
    final List<String> allFiles = [
      widget.filePath,
      if (widget.additionalFiles != null) ...widget.additionalFiles!
    ];
    final StringBuffer buffer = StringBuffer();
    for (int i = 0; i < allFiles.length; i++) {
      String fileName = path.basenameWithoutExtension(allFiles[i]);
      String fileExtension = path.extension(allFiles[i]);
      if (fileName.endsWith('_original')) {
        fileName = fileName.substring(0, fileName.length - 9); 
      }
      if (fileName.contains('_modified_')) {
        fileName = fileName.substring(0, fileName.lastIndexOf('_modified_'));
      } else if (fileName.endsWith('_modified')) {
        fileName = fileName.substring(0, fileName.length - 9); 
      }
      buffer.write('$fileName$fileExtension');
      if (i < allFiles.length - 1) {
        buffer.write('\n'); 
      }
    }
    final TextEditingController fileListController = TextEditingController(text: buffer.toString());
    final double maxHeight = MediaQuery.of(context).size.height * 0.25;
    return Container(
      constraints: BoxConstraints(maxHeight: maxHeight),
      margin: const EdgeInsets.all(4.0), 
      child: Stack(
        children: [
          Scrollbar(
            controller: _fileListScrollController,
            child: SingleChildScrollView(
              controller: _fileListScrollController,
              scrollDirection: Axis.vertical,
              child: TextFormField(
                controller: fileListController,
                decoration: InputDecoration(
                  labelText: '\n文件列表',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12.0),
                    borderSide: BorderSide.none,
                  ),
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12.0),
                    borderSide: BorderSide.none,
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12.0),
                    borderSide: BorderSide.none,
                  ),
                  filled: true,
                  fillColor: Colors.transparent,
                ),
                maxLines: null, 
                enabled: false, 
                textAlign: TextAlign.start, 
                style: const TextStyle(
                  fontFamily: 'MapleMono',
                  fontSize: 14,
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
  @override
  Widget build(BuildContext context) {
    final Size screenSize = MediaQuery.of(context).size;
    final bool isLandscape = screenSize.width > screenSize.height;
    return Scaffold(
      body: Stack(
        children: [
          if (_currentCoverImage != null)
    Positioned.fill(
      child: RotationTransition(
        turns: effectLevel != EffectLevel.low ? _backgroundRotationAnimation : const AlwaysStoppedAnimation(0.0),
        child: Container(
          alignment: Alignment.center,
          child: Transform.scale(
            scale: 2.0, 
            child: Container(
              decoration: BoxDecoration(
                image: DecorationImage(
                  image: MemoryImage(_currentCoverImage!),
                  fit: BoxFit.contain,
                  colorFilter: ColorFilter.mode(
                    Theme.of(context).brightness == Brightness.dark
                        ? Colors.black.withOpacity(0.05)
                        : Colors.white.withOpacity(0.05),
                    BlendMode.srcOver,
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    ),
  if (_currentCoverImage != null)
    Positioned.fill(
      child: Container(
        alignment: Alignment.center,
        child: Transform.scale(
          scale: 2.0, 
          child: ClipRect( 
            child: BackdropFilter(
              filter: ui.ImageFilter.blur(sigmaX: 25.0, sigmaY: 25.0), 
              child: Container(
                color: Theme.of(context).brightness == Brightness.dark
                    ? Colors.black.withOpacity(0.30)
                    : Colors.white.withOpacity(0.25), 
              ),
            ),
          ),
        ),
      ),
    ),
  LayoutBuilder(
    builder: (context, constraints) {
      if (isLandscape) {
        return Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const SizedBox(width: 64),
            SizedBox(
              width: constraints.maxWidth * 0.35,
              child: SingleChildScrollView(
                child: Column(
                  children: [
                    SizedBox(height: MediaQuery.of(context).padding.top),
                    const SizedBox(height: 64),
                    _buildCoverSection(), 
                  ],
                ),
              ),
            ),
            Expanded(
              child: SingleChildScrollView(
                padding: const EdgeInsets.all(64.0),
                child: Form(
                  key: _formKey,
                  child: ConstrainedBox(
                    constraints: const BoxConstraints(maxWidth: 800),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: _buildFormFields(), 
                    ),
                  ),
                ),
              ),
            ),
          ],
        );
      } else {
        return SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Form(
            key: _formKey,
            child: Center(
              child: ConstrainedBox(
                constraints: const BoxConstraints(maxWidth: 800),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    SizedBox(height: MediaQuery.of(context).padding.top),
                    const SizedBox(height: 48),
                    _buildCoverSection(), 
                    ..._buildFormFields(), 
                  ],
                ),
              ),
            ),
          ),
        );
      }
    },
  ),
          Positioned(
            top: MediaQuery.of(context).padding.top + 16, 
            left: 12.0,
            child: LiquidGlassLayer(
              settings: GlassEffectConfig.smallButtonSettings(level: effectLevel),
              child: LiquidGlass.inLayer(
                shape: LiquidRoundedRectangle(
                  borderRadius: const Radius.circular(20.0),
                ),
                child: SizedBox(
                  width: 40.0,
                  height: 40.0,
                  child: FloatingActionButton(
                    onPressed: () {
                      Navigator.of(context).pop();
                    },
                    mini: true,
                    backgroundColor: Colors.transparent,
                    elevation: 0,
                    child: const Icon(Icons.arrow_back),
                  ),
                ),
              ),
            ),
          ),
          Positioned(
            top: MediaQuery.of(context).padding.top + 16,
            right: 12.0,
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                LiquidGlassLayer(
                  settings: GlassEffectConfig.largeButtonSettings(level: effectLevel),
                  child: LiquidGlass.inLayer(
                    shape: LiquidRoundedRectangle(
                      borderRadius: const Radius.circular(20.0),
                    ),
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
                      decoration: BoxDecoration(
                        borderRadius: BorderRadius.circular(20.0),
                      ),
                      child: Material(
                        color: Colors.transparent,
                        child: InkWell(
                          onTap: _resetChanges,
                          borderRadius: BorderRadius.circular(20.0),
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Text(
                                '还原更改',
                                style: TextStyle(
                                  fontFamily: 'MapleMono',
                                  fontSize: 14,
                                  fontWeight: FontWeight.normal,
                                  color: Theme.of(context).textTheme.bodyMedium?.color,
                                ),
                              ),
                              const SizedBox(width: 6),
                              const Icon(Icons.refresh, size: 20),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                LiquidGlassLayer(
                  settings: GlassEffectConfig.largeButtonSettings(level: effectLevel),
                  child: LiquidGlass.inLayer(
                    shape: LiquidRoundedRectangle(
                      borderRadius: const Radius.circular(20.0),
                    ),
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
                      decoration: BoxDecoration(
                        borderRadius: BorderRadius.circular(20.0),
                      ),
                      child: Material(
                        color: Colors.transparent,
                        child: InkWell(
                          onTap: _saveTags,
                          borderRadius: BorderRadius.circular(20.0),
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Text(
                                '保存',
                                style: TextStyle(
                                  fontFamily: 'MapleMono',
                                  fontSize: 14,
                                  fontWeight: FontWeight.normal,
                                  color: Theme.of(context).textTheme.bodyMedium?.color,
                                ),
                              ),
                              const SizedBox(width: 6),
                              const Icon(Icons.save, size: 20),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:dynamic_color/dynamic_color.dart';
import 'package:fluttertoast/fluttertoast.dart';
import 'settings_page.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:io';
import 'package:path/path.dart' as path;
import 'tag_editor_ui.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:file_picker/file_picker.dart';
import 'package:cross_file/cross_file.dart';
import 'package:liquid_glass_renderer/liquid_glass_renderer.dart';
import 'config/glass_effect_config.dart';
import 'isolate_utils.dart';
import 'package:http/http.dart' as http;
import 'dart:ui';
import 'package:path_provider/path_provider.dart';
import 'package:desktop_drop/desktop_drop.dart';
Future<void> _clearCacheDirectory() async {
  try {
    final tempDir = await getTemporaryDirectory();
    if (await tempDir.exists()) {
      await tempDir.delete(recursive: true);
      await tempDir.create(recursive: true);
    }
    if (kDebugMode) {
      print('KDEBUG: 缓存目录已清理');
    }
  } catch (e) {
    if (kDebugMode) {
      print('KDEBUG: 清理缓存目录时出错: $e');
    }
  }
}
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  if (Platform.isAndroid) {
    await _clearCacheDirectory();
  }
  SharedPreferences prefs = await SharedPreferences.getInstance();
  bool? isDarkMode = prefs.getBool('isDarkMode');
  runApp(MyApp(initialIsDarkMode: isDarkMode));
}
class MyApp extends StatefulWidget {
  const MyApp({super.key, this.initialIsDarkMode});
  final bool? initialIsDarkMode;
  @override
  State<MyApp> createState() => _MyAppState();
}
class _MyAppState extends State<MyApp> {
  bool? _isDarkMode;
  void _toggleTheme() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    setState(() {
      if (_isDarkMode == null) {
        _isDarkMode = false;
      } else if (_isDarkMode == false) {
        _isDarkMode = true;
      } else {
        _isDarkMode = null;
      }
    });
    if (_isDarkMode != null) {
      await prefs.setBool('isDarkMode', _isDarkMode!);
    } else {
      await prefs.remove('isDarkMode');
    }
  }
  @override
  void initState() {
    super.initState();
    _isDarkMode = widget.initialIsDarkMode;
  }
  @override
  Widget build(BuildContext context) {
    return DynamicColorBuilder(
      builder: (ColorScheme? lightDynamic, ColorScheme? darkDynamic) {
        ThemeMode themeMode = _isDarkMode == null
            ? ThemeMode.system
            : (_isDarkMode! ? ThemeMode.dark : ThemeMode.light);
        return MaterialApp(
          title: '音乐标签编辑器',
          themeMode: themeMode,
          theme: ThemeData(
            useMaterial3: true,
            fontFamily: 'MapleMono',
            colorScheme: lightDynamic ??
                ColorScheme.fromSeed(
                  seedColor: Colors.blue,
                  brightness: Brightness.light,
                ),
          ),
          darkTheme: ThemeData(
            useMaterial3: true,
            fontFamily: 'MapleMono',
            colorScheme: darkDynamic ??
                ColorScheme.fromSeed(
                  seedColor: Colors.blue,
                  brightness: Brightness.dark,
                ),
            scaffoldBackgroundColor: Colors.black,
          ),
          home: HomePage(
            title: '音乐标签编辑',
            isDarkMode: _isDarkMode,
            toggleTheme: _toggleTheme,
          ),
        );
      },
    );
  }
}
class HomePage extends StatefulWidget {
  const HomePage({
    super.key, 
    required this.title,
    required this.isDarkMode,
    required this.toggleTheme,
  });
  final String title;
  final bool? isDarkMode;
  final VoidCallback toggleTheme;
  @override
  State<HomePage> createState() => _HomePageState();
}
class _HomePageState extends State<HomePage> {
  int _effectLevel = 1;
  Uint8List? _backgroundImageBytes;
  Future<void> _loadBackgroundImage() async {
    try {
      final response = await http.get(Uri.parse('https://bing.img.run/uhd.php'));
      if (response.statusCode == 200) {
        setState(() {
          _backgroundImageBytes = response.bodyBytes;
        });
      }
    } catch (e) {
      if (kDebugMode) {
        print('KDEBUG: 无法加载背景图片: $e');
      }
    }
  }
  Future<bool> _requestFullStoragePermission() async {
    if (Platform.isAndroid) {
      final androidVersion = int.tryParse(Platform.operatingSystemVersion.replaceAll(RegExp(r'[^\d.]'), '').split('.').first) ?? 0;
      if (androidVersion >= 11) {
        var status = await Permission.manageExternalStorage.status;
        if (!status.isGranted) {
          status = await Permission.manageExternalStorage.request();
          return status.isGranted;
        }
        return true;
      } else {
        var status = await Permission.storage.status;
        if (!status.isGranted) {
          status = await Permission.storage.request();
          return status.isGranted;
        }
        return true;
      }
    }
    return true;
  }
  void _selectMusicFile() async {
    bool hasPermission = await _requestFullStoragePermission();
    if (!hasPermission) {
      if (mounted) {
        showDialog(
          context: context,
          builder: (BuildContext context) {
            return AlertDialog(
              title: const Text('权限不足'),
              content: const Text('需要完全存储权限才能选择和修改文件'),
              actions: [
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pop();
                  },
                  child: const Text('确定'),
                ),
              ],
            );
          },
        );
      }
      return;
    }
    if (mounted) {
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext context) {
          return AlertDialog(
            title: const Text('正在获取音频'),
            content: const Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                CircularProgressIndicator(),
                SizedBox(height: 20),
                Text('请稍候...'),
              ],
            ),
          );
        },
      );
    }
    await Future.delayed(const Duration(milliseconds: 100));
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a'],
        allowMultiple: true,
      );
      if (result == null || result.files.isEmpty) {
        if (mounted) {
          Navigator.of(context).pop();
        }
        Fluttertoast.showToast(
          msg: '未选择任何文件',
        );
        return;
      }
      if (result.files.length > 1000) {
        if (mounted) {
          showDialog(
            context: context,
            builder: (BuildContext context) {
              return AlertDialog(
                title: const Text('文件数量过多'),
                content: Text('您选择了 ${result.files.length} 个文件，超过最大限制 1000 个文件。\n请减少选择的文件数量。'),
                actions: [
                  TextButton(
                    onPressed: () {
                      Navigator.of(context).pop();
                    },
                    child: const Text('确定'),
                  ),
                ],
              );
            },
          );
        }
        return;
      }
      List<PlatformFile> selectedFiles = result.files.toList();
      if (selectedFiles.length == 1) {
        await _processSingleFile(selectedFiles.first);
      } else {
        await _processMultipleFilesInSingleView(selectedFiles);
      }
    } catch (e) {
      if (mounted) {
        Navigator.of(context).pop();
      }
      if (mounted) {
        Navigator.of(context).pop();
      }
      if (kDebugMode) {
        print('选择或处理文件时出错: $e');
      }
      if (mounted) {
        showDialog(
          context: context,
          builder: (BuildContext context) {
            return AlertDialog(
              title: const Text('处理文件出错'),
              content: Text('处理文件时出错: $e'),
              actions: [
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pop();
                  },
                  child: const Text('确定'),
                ),
              ],
            );
          },
        );
      }
    }
  }
  Future<void> _processSingleFile(PlatformFile selectedFile) async {
    final String fileName = path.basename(selectedFile.path!);
    final String originalFilePath = selectedFile.path!;
    if (kDebugMode) {
      print('KDEBUG: 用户选择的文件路径: $originalFilePath');
      print('KDEBUG: 用户选择的文件名: $fileName');
    }
    if (mounted) {
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext context) {
          return AlertDialog(
            title: const Text('正在读取文件'),
            content: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const CircularProgressIndicator(),
                const SizedBox(height: 20),
                Text('正在读取 $fileName...'),
              ],
            ),
          );
        },
      );
    }
    try {
      await Future.delayed(const Duration(milliseconds: 100));
      final tags = await compute(readAudioTagsInBackground, ReadTagsParams(originalFilePath));
      if (kDebugMode) {
        print('读取到的标签: $tags');
      }
      if (mounted) {
        Navigator.of(context).pop();
      }
      if (mounted) {
        Navigator.of(context).pop();
      }
      if (tags != null && mounted) {
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => TagEditorUI(
              tag: tags, 
              filePath: originalFilePath, 
              realFilePath: originalFilePath, 
            ),
          ),
        );
      } else if (mounted) {
        showDialog(
          context: context,
          builder: (BuildContext context) {
            return AlertDialog(
              title: const Text('读取失败'),
              content: const Text('未能读取文件标签信息'),
              actions: [
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pop();
                  },
                  child: const Text('确定'),
                ),
              ],
            );
          },
        );
      }
    } catch (e) {
      if (mounted) {
        Navigator.of(context).pop();
      }
      if (kDebugMode) {
        print('选择或处理文件时出错: $e');
      }
      if (mounted) {
        showDialog(
          context: context,
          builder: (BuildContext context) {
            return AlertDialog(
              title: const Text('处理文件出错'),
              content: Text('处理文件时出错: $e'),
              actions: [
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pop();
                  },
                  child: const Text('确定'),
                ),
              ],
            );
          },
        );
      }
    }
  }
  Future<void> _processMultipleFilesInSingleView(List<PlatformFile> selectedFiles) async {
    if (kDebugMode) {
      print('KDEBUG: 处理多个文件 (${selectedFiles.length} 个)');
    }
    if (mounted) {
      Navigator.of(context).pop();
    }
    if (mounted) {
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext context) {
          return AlertDialog(
            title: const Text('正在处理文件'),
            content: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const CircularProgressIndicator(),
                const SizedBox(height: 20),
                Text('正在处理 ${selectedFiles.length} 个文件...'),
              ],
            ),
          );
        },
      );
    }
    try {
      await Future.delayed(const Duration(milliseconds: 100));
      List<String> filePaths = [];
      String? firstOriginalFilePath;
      for (int i = 0; i < selectedFiles.length; i++) {
        final selectedFile = selectedFiles[i];
        final String fileName = path.basename(selectedFile.path!);
        if (i == 0) {
          firstOriginalFilePath = selectedFile.path!;
        }
        if (kDebugMode) {
          print('KDEBUG: 处理第 ${i+1}/${selectedFiles.length} 个文件: $fileName');
        }
        filePaths.add(selectedFile.path!);
      }
      final tags = await compute(readAudioTagsInBackground, ReadTagsParams(filePaths[0]));
      if (kDebugMode) {
        print('读取到的第一个文件的标签: $tags');
      }
      if (mounted) {
        Navigator.of(context).pop();
      }
      if (tags != null && mounted) {
        List<String> additionalFiles = filePaths.sublist(1);
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => TagEditorUI(
              tag: tags, 
              filePath: filePaths[0], 
              realFilePath: firstOriginalFilePath, 
              additionalFiles: additionalFiles, 
            ),
          ),
        );
      } else if (mounted) {
        showDialog(
          context: context,
          builder: (BuildContext context) {
            return AlertDialog(
              title: const Text('读取失败'),
              content: const Text('未能读取文件标签信息'),
              actions: [
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pop();
                  },
                  child: const Text('确定'),
                ),
              ],
            );
          },
        );
      }
    } catch (e) {
      if (mounted) {
        Navigator.of(context).pop();
      }
      if (kDebugMode) {
        print('选择或处理文件时出错: $e');
      }
      if (mounted) {
        showDialog(
          context: context,
          builder: (BuildContext context) {
            return AlertDialog(
              title: const Text('处理文件出错'),
              content: Text('处理文件时出错: $e'),
              actions: [
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pop();
                  },
                  child: const Text('确定'),
                ),
              ],
            );
          },
        );
      }
    }
  }
  @override
  void initState() {
    super.initState();
    _loadEffectLevel();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadBackgroundImage();
    });
  }
  Future<void> _loadEffectLevel() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    setState(() {
      _effectLevel = prefs.getInt('effectLevel') ?? 1; 
    });
  }
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Stack(
        children: [
          if (_backgroundImageBytes != null)
            Positioned.fill(
              child: Transform.scale(
                scale: 1, 
                child: Image.memory(
                  _backgroundImageBytes!,
                  fit: BoxFit.cover, 
                  alignment: Alignment.center,
                ),
              ),
            ),
          if (_backgroundImageBytes != null)
            Positioned.fill(
              child: BackdropFilter(
                filter: ImageFilter.blur(sigmaX: 5.0, sigmaY: 5.0),
                child: Container(
                  color: Theme.of(context).brightness == Brightness.dark 
                    ? Colors.black.withValues(alpha: 0.25) 
                    : Colors.white.withValues(alpha: 0.25),
                ),
              ),
            ),
          Positioned.fill(
            child: DropTarget(
              onDragDone: (detail) {
                _processDroppedFiles(detail.files);
              },
              child: Container(
                color: Colors.transparent, 
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: <Widget>[
                      Icon(
                        Icons.music_note,
                        size: 100,
                        color: Theme.of(context).brightness == Brightness.dark 
                          ? Colors.white 
                          : Colors.black,
                      ),
                      const SizedBox(height: 20),
                      Text(
                        '选择音频文件开始编辑标签',
                        style: TextStyle(
                          fontSize: 18,
                          color: Theme.of(context).brightness == Brightness.dark 
                            ? Colors.white 
                            : Colors.black,
                        ),
                      ),
                      const SizedBox(height: 40),
                      LiquidGlassLayer(
                        settings: GlassEffectConfig.fileSelectorSettings(
                          level: _effectLevel <= 1 
                            ? EffectLevel.low 
                            : (_effectLevel == 2 ? EffectLevel.medium : EffectLevel.high)
                        ),
                        child: LiquidGlass.inLayer(
                          shape: LiquidRoundedRectangle(
                            borderRadius: const Radius.circular(28.0),
                          ),
                          child: Container(
                            padding: const EdgeInsets.symmetric(horizontal: 24.0, vertical: 16.0),
                            decoration: BoxDecoration(
                              borderRadius: BorderRadius.circular(28.0),
                            ),
                            child: Material(
                              color: Colors.transparent,
                              child: InkWell(
                                onTap: _selectMusicFile,
                                borderRadius: BorderRadius.circular(28.0),
                                child: const Row(
                                  mainAxisSize: MainAxisSize.min,
                                  children: [
                                    Icon(Icons.music_note),
                                    SizedBox(width: 8),
                                    Text('选择音频文件'),
                                  ],
                                ),
                              ),
                            ),
                          ),
                        ),
                      ),
                      const SizedBox(height: 20),
                      Text(
                        '或者将音频文件拖拽到这里',
                        style: TextStyle(
                          fontSize: 14,
                          color: Theme.of(context).brightness == Brightness.dark 
                            ? Colors.white70 
                            : Colors.black54,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
          Positioned(
            top: MediaQuery.of(context).padding.top + 12.0,
            right: 12.0,
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                LiquidGlassLayer(
                  settings: GlassEffectConfig.smallButtonSettings(
                    level: _effectLevel <= 1 
                      ? EffectLevel.low 
                      : (_effectLevel == 2 ? EffectLevel.medium : EffectLevel.high)
                  ),
                  child: LiquidGlass.inLayer(
                    shape: LiquidRoundedRectangle(
                      borderRadius: const Radius.circular(20.0),
                    ),
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
                      decoration: BoxDecoration(
                        borderRadius: BorderRadius.circular(20.0),
                      ),
                      child: Material(
                        color: Colors.transparent,
                        child: InkWell(
                          onTap: widget.toggleTheme,
                          borderRadius: BorderRadius.circular(20.0),
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                widget.isDarkMode == null
                                    ? Icons.auto_mode
                                    : (widget.isDarkMode! ? Icons.dark_mode : Icons.light_mode),
                              ),
                              const SizedBox(width: 6),
                              Text(
                                widget.isDarkMode == null
                                    ? '跟随系统'
                                    : (widget.isDarkMode! ? '深色模式' : '浅色模式'),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 16),
                LiquidGlassLayer(
                  settings: GlassEffectConfig.smallButtonSettings(
                    level: _effectLevel <= 1 
                      ? EffectLevel.low 
                      : (_effectLevel == 2 ? EffectLevel.medium : EffectLevel.high)
                  ),
                  child: LiquidGlass.inLayer(
                    shape: LiquidRoundedRectangle(
                      borderRadius: const Radius.circular(20.0),
                    ),
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
                      decoration: BoxDecoration(
                        borderRadius: BorderRadius.circular(20.0),
                      ),
                      child: Material(
                        color: Colors.transparent,
                        child: InkWell(
                          onTap: () {
                            Navigator.push(
                              context,
                              MaterialPageRoute(
                                builder: (context) => const SettingsPage(),
                              ),
                            );
                          },
                          borderRadius: BorderRadius.circular(20.0),
                          child: const Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(Icons.settings),
                              SizedBox(width: 6),
                              Text('设置'),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 8),
              ],
            ),
          ),
        ],
      ),
    );
  }
  void _processDroppedFiles(List<XFile> files) async {
    if (files.isEmpty) return;
    List<XFile> audioFiles = files.where((file) {
      String? extension = path.extension(file.path).toLowerCase();
      return ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.m4a'].contains(extension);
    }).toList();
    if (audioFiles.isEmpty) {
      Fluttertoast.showToast(msg: '未找到支持的音频文件');
      return;
    }
    if (audioFiles.length > 1000) {
      if (mounted) {
        showDialog(
          context: context,
          builder: (BuildContext context) {
            return AlertDialog(
              title: const Text('文件数量过多'),
              content: Text('您拖入了 ${audioFiles.length} 个文件，超过最大限制 1000 个文件。\n请减少拖入的文件数量。'),
              actions: [
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pop();
                  },
                  child: const Text('确定'),
                ),
              ],
            );
          },
        );
      }
      return;
    }
    if (mounted) {
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext context) {
          return AlertDialog(
            title: const Text('正在处理文件'),
            content: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const CircularProgressIndicator(),
                const SizedBox(height: 20),
                Text('正在处理 ${audioFiles.length} 个文件...'),
              ],
            ),
          );
        },
      );
    }
    try {
      await Future.delayed(const Duration(milliseconds: 100));
      List<String> filePaths = [];
      String? firstOriginalFilePath;
      for (int i = 0; i < audioFiles.length; i++) {
        final XFile file = audioFiles[i];
        final String fileName = path.basename(file.path);
        if (i == 0) {
          firstOriginalFilePath = file.path;
        }
        if (kDebugMode) {
          print('KDEBUG: 处理第 ${i+1}/${audioFiles.length} 个文件: $fileName');
        }
        filePaths.add(file.path);
      }
      final tags = await compute(readAudioTagsInBackground, ReadTagsParams(filePaths[0]));
      if (kDebugMode) {
        print('读取到的第一个文件的标签: $tags');
      }
      if (mounted) {
        Navigator.of(context).pop();
      }
      if (tags != null && mounted) {
        if (filePaths.length == 1) {
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => TagEditorUI(
                tag: tags,
                filePath: filePaths[0], 
                realFilePath: firstOriginalFilePath, 
              ),
            ),
          );
        } else {
          List<String> additionalFiles = filePaths.sublist(1);
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => TagEditorUI(
                tag: tags,
                filePath: filePaths[0], 
                realFilePath: firstOriginalFilePath, 
                additionalFiles: additionalFiles, 
              ),
            ),
          );
        }
      } else if (mounted) {
        showDialog(
          context: context,
          builder: (BuildContext context) {
            return AlertDialog(
              title: const Text('读取失败'),
              content: const Text('未能读取文件标签信息'),
              actions: [
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pop();
                  },
                  child: const Text('确定'),
                ),
              ],
            );
          },
        );
      }
    } catch (e) {
      if (mounted) {
        Navigator.of(context).pop();
      }
      if (kDebugMode) {
        print('处理拖拽文件时出错: $e');
      }
      if (mounted) {
        showDialog(
          context: context,
          builder: (BuildContext context) {
            return AlertDialog(
              title: const Text('处理文件出错'),
              content: Text('处理文件时出错: $e'),
              actions: [
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pop();
                  },
                  child: const Text('确定'),
                ),
              ],
            );
          },
        );
      }
    }
  }
}
import 'package:audiotags/audiotags.dart';
import 'package:flutter/foundation.dart';
class ReadTagsParams {
  final String filePath;
  ReadTagsParams(this.filePath);
}
class SaveTagsParams {
  final String filePath;
  final Tag tag;
  SaveTagsParams(this.filePath, this.tag);
}
Future<Tag?> readAudioTagsInBackground(ReadTagsParams params) async {
  try {
    if (kDebugMode) {
      print('在 isolate 中读取音频标签，文件路径: ${params.filePath}');
    }
    final tag = await AudioTags.read(params.filePath);
    if (kDebugMode) {
      print('在 isolate 中成功读取标签: 标题=${tag?.title}, 艺术家=${tag?.trackArtist}');
    }
    return tag;
  } catch (e) {
    if (kDebugMode) {
      print('在 isolate 中读取音频标签时发生错误: $e');
    }
    return null;
  }
}
Future<bool> saveAudioTagsInBackground(SaveTagsParams params) async {
  try {
    if (kDebugMode) {
      print('在 isolate 中保存音频标签，文件路径: ${params.filePath}');
    }
    await AudioTags.write(params.filePath, params.tag);
    if (kDebugMode) {
      print('在 isolate 中成功保存标签到文件: ${params.filePath}');
    }
    return true;
  } catch (e) {
    if (kDebugMode) {
      print('在 isolate 中保存音频标签时发生错误: $e');
    }
    return false;
  }
}
import 'dart:io';
import 'package:audiotags/audiotags.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'isolate_utils.dart';
Future<Tag?> readAudioTags(String filePath) async {
  try {
    if (kDebugMode) {
      print('尝试读取音频标签，文件路径: $filePath');
      print('KDEBUG: 文件是否存在: ${await File(filePath).exists()}');
      print('KDEBUG: 文件大小: ${await File(filePath).length()} 字节');
    }
    final tag = await compute(readAudioTagsInBackground, ReadTagsParams(filePath));
    if (kDebugMode) {
      print('成功读取标签: 标题=${tag?.title}, 艺术家=${tag?.trackArtist}');
    }
    return tag;
  } on MissingPluginException catch (e) {
    if (kDebugMode) {
      print('插件异常: $e');
    }
    if (kDebugMode) {
      print('可能是本地库文件缺失或未正确加载');
    }
    return null;
  } on PlatformException catch (e) {
    if (kDebugMode) {
      print('平台异常: $e');
    }
    if (kDebugMode) {
      print('错误代码: ${e.code}, 错误详情: ${e.details}');
    }
    return null;
  } catch (e) {
    if (kDebugMode) {
      print('读取音频标签时发生未知错误: $e');
    }
    return null;
  }
}
